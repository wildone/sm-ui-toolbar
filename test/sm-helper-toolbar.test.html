<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>sm-helper-toolbar</title>
    <script src="../../webcomponentsjs/webcomponents.min.js"></script>
    <script src="../../web-component-tester/browser.js"></script>
    <script src="../../test-fixture/test-fixture-mocha.js"></script>
    <link rel="import" href="../../test-fixture/test-fixture.html">

    <!-- Use Simpla text for testing -->
    <link rel="import" href="../../simpla-text/simpla-text.html">

    <!-- Import the element to test -->
    <link rel="import" href="../sm-helper-toolbar.html">
  </head>
  <body>
    <test-fixture id="text">
      <template>
        <simpla-text></simpla-text>
      </template>
    </test-fixture>
    <test-fixture id="default">
      <template>
        <sm-helper-toolbar></sm-helper-toolbar>
      </template>
    </test-fixture>
    <script>
      describe('<sm-helper-toolbar>', function() {

        var component,
            text;

        beforeEach(function() {
          component = fixture('default');
          text = fixture('text');

          component.scribe = text.scribe;
        });

        it('is okay', function() {
          expect(component).to.be.ok;
        });

        describe('commands', function() {
          var defaultSet = ['bold', 'italic', 'underline', 'link'],
              noBold = ['italic', 'underline', 'link'],
              toolsTemplate;

          beforeEach(function() {
            component.set('commands', defaultSet);
            toolsTemplate = component.$.tools;
          });

          it('should hide commands that are disabled', function() {
            component.set('commands', noBold);
            toolsTemplate.render();

            expect(component.$$('.tool#bold')).to.not.be.ok;
          });

          it('should show commands that are enabled', function() {
            component.set('commands', noBold);
            component.set('commands', defaultSet);

            toolsTemplate.render();

            expect(component.$$('.tool#bold')).to.be.ok;
          });

          describe('bold, italic, underline', function() {
            var fakeCommand,
                getCommandStub,

                // Commands
                buttons = {};

            beforeEach(function() {
              fakeCommand = {
                execute: sinon.spy()
              };

              getCommandStub = sinon.stub(component.scribe, 'getCommand').returns(fakeCommand);

              toolsTemplate.render();
              ['bold', 'italic', 'underline'].forEach(function(tool) {
                buttons[tool] = component.$$('.tool#'+tool);
              });
            });

            it('should call execute on corresponding scribe command', function() {
              for (var tool in buttons) {
                buttons[tool].click();
                expect(getCommandStub.calledWith(tool), 'getCommand called with ' + tool).to.be.true;
                expect(fakeCommand.execute.called, 'execute called for ' + tool).to.be.true;
                fakeCommand.execute.reset();
                getCommandStub.reset();
              }
            });
          });
        });

        describe('positioning and range', function() {
          var fakeWindowOffsets = { pageXOffset: 100, pageYOffset: 250 },
              fakeWindowBounds = { innerWidth: 800, innerHeight: 600 },
              fakeRangeBounds = { top: 300, left: 400, width: 100 },
              fakeRangeOutsideBounds = { top: 0, left: 0, width: 100 },
              fakeRange,
              // Should be centre of range, at the top of the range
              //  plus any scroll offsets of the window
              fakeToolbarPosition = {
                top: fakeRangeBounds.top + fakeWindowOffsets.pageYOffset,
                left: fakeRangeBounds.left + fakeRangeBounds.width/2 + fakeWindowOffsets.pageXOffset
              };

          before(function() {
            window.pageXOffset = fakeWindowOffsets.pageXOffset;
            window.pageYOffset = fakeWindowOffsets.pageYOffset;
            window.innerWidth = fakeWindowBounds.innerWidth;
            window.innerHeight = fakeWindowBounds.innerHeight;
          });

          beforeEach(function() {
            fakeRange = {
              getBoundingClientRect: function() {
                return fakeRangeBounds;
              }
            };
          });

          describe('positioning', function() {
            it('should update styling when position changes', function() {
              var top = 200,
                  left = 100;

              // Must set using Polymers, so as to trigger any observers
              component.set('position.top', top);
              component.set('position.left', left);

              expect(component.style.top).to.equal(top + 'px');
              expect(component.style.left).to.equal(left + 'px');
            });

            it('should be inside viewport at all times', function() {
              var componentBounds;
              component.active = true;

              sinon.stub(fakeRange, 'getBoundingClientRect').returns(fakeRangeOutsideBounds);
              component.range = fakeRange;
              componentBounds = component.getBoundingClientRect();

              expect(componentBounds.top).to.be.at.least(window.pageYOffset);
              expect(componentBounds.left).to.be.at.least(window.pageXOffset);
            });
          });

          describe('range', function() {
            it('should update position on change of range', function() {
              component.range = fakeRange;

              expect(component.position.left).to.equal(fakeToolbarPosition.left);
              expect(component.position.top).to.equal(fakeToolbarPosition.top);
            });
          });
        });
      });
    </script>
  </body>
</html>
