<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>sm-helper-toolbar</title>
    <script src="../../webcomponentsjs/webcomponents.min.js"></script>
    <script src="../../web-component-tester/browser.js"></script>
    <script src="../../test-fixture/test-fixture-mocha.js"></script>
    <link rel="import" href="../../test-fixture/test-fixture.html">

    <!-- Use Simpla text for testing -->
    <link rel="import" href="../../simpla-text/simpla-text.html">

    <!-- Import the element to test -->
    <link rel="import" href="../sm-helper-toolbar.html">
  </head>
  <body>
    <test-fixture id="text">
      <template>
        <simpla-text></simpla-text>
      </template>
    </test-fixture>
    <test-fixture id="default">
      <template>
        <sm-helper-toolbar></sm-helper-toolbar>
      </template>
    </test-fixture>
    <script>
      describe('<sm-helper-toolbar>', function() {

        var component,
            text;

        function expandCommand(command) {
          return { name: command, enabled: true, active: false, use: true };
        }

        beforeEach(function() {
          component = fixture('default');
          text = fixture('text');

          component.scribe = text.scribe;
        });

        it('is okay', function() {
          expect(component).to.be.ok;
        });

        describe('commands', function() {
          var defaultCommandNames = ['bold', 'italic', 'underline', 'link'],
              defaultSet = defaultCommandNames.map(expandCommand),
              toolsTemplate;

          beforeEach(function() {
            component.set('commands', defaultSet);
            toolsTemplate = component.$.tools;
          });

          it('should hide commands that are disabled', function() {
            component.set('commands.0.use', false);
            toolsTemplate.render();

            expect(component.$$('.tool#bold')).to.not.be.ok;
          });

          it('should show commands that are enabled', function() {
            component.set('commands.0.use', false);
            component.set('commands.0.use', true);

            toolsTemplate.render();

            expect(component.$$('.tool#bold')).to.be.ok;
          });

          it('should use only commands specified by scribe instance', function() {
            var usingLink;

            // Dont use link
            component.scribe._smEnabled = ['bold', 'italic', 'underline'];

            // Do what the observer would normally do
            component._checkUsedCommands(component.scribe, component.commands);

            usingLink = component.commands.some(function(command) {
              return command.name === 'link' && command.use;
            });

            expect(usingLink).to.be.false;

          });

          describe('bold, italic, underline', function() {
            var fakeCommand,
                getCommandStub,

                // Commands
                buttons = {};

            beforeEach(function() {
              fakeCommand = {
                execute: sinon.spy()
              };

              getCommandStub = sinon.stub(component.scribe, 'getCommand').returns(fakeCommand);

              toolsTemplate.render();
              ['bold', 'italic', 'underline'].forEach(function(tool) {
                buttons[tool] = component.$$('.tool#'+tool);
              });
            });

            it('should call execute on corresponding scribe command', function() {
              for (var tool in buttons) {
                buttons[tool].click();
                expect(getCommandStub.calledWith(tool), 'getCommand called with ' + tool).to.be.true;
                expect(fakeCommand.execute.called, 'execute called for ' + tool).to.be.true;
                fakeCommand.execute.reset();
                getCommandStub.reset();
              }
            });

            it('should call the handler even if event originates from within', function() {
              var innerButton = buttons.bold.children[0];
              innerButton.click();
              expect(getCommandStub.calledWith('bold')).to.be.true;
              expect(fakeCommand.execute.called).to.be.true;
            });
          });

          describe('active / inactive', function() {
            it('should set active on button when active is true on command', function() {
              var firstButton;

              component.set('commands.0.active', true);
              toolsTemplate.render();

              firstButton = Polymer.dom(component.root).querySelectorAll('.tool')[0];
              expect(firstButton.active).to.be.true;
            });

            it('should update the tool based on scribe', function() {
              // Test out on bold
              var scribeCommand = component.scribe.getCommand('bold'),
                  commandStub = sinon.stub(scribeCommand, 'queryState').returns(true);

              // Ensure its disabled
              component.set('commands.0.active', false);

              // Fire off something to kick start it
              component.scribe.trigger('selectionchange');

              expect(component.commands[0].active).to.be.true;
            });
          });

          describe('enabled / disabled', function() {
            it('should set enabled attr on button when enabled is true on command', function() {
              var firstButton;

              component.set('commands.0.enabled', false);
              toolsTemplate.render();

              firstButton = Polymer.dom(component.root).querySelectorAll('.tool')[0];
              expect(firstButton.hasAttribute('disabled')).to.be.true;
            });

            it('should update the tool based on scribe', function() {
              // Test out on bold
              var scribeCommand = component.scribe.getCommand('bold'),
                  commandStub = sinon.stub(scribeCommand, 'queryEnabled').returns(true);

              // Ensure its disabled
              component.set('commands.0.enabled', false);

              // Fire off something to kick start it
              component.scribe.trigger('selectionchange');

              expect(component.commands[0].enabled).to.be.true;
            });
          });
        });

        describe('positioning and range', function() {
          var fakeWindowOffsets = { pageXOffset: 100, pageYOffset: 250 },
              fakeWindowBounds = { innerWidth: 800, innerHeight: 600 },
              fakeRangeBounds = { top: 300, left: 400, width: 100 },
              fakeRangeOutsideBounds = { top: 0, left: 0, width: 100 },
              fakeRange,
              // Should be centre of range, at the top of the range
              //  plus any scroll offsets of the window
              fakeToolbarPosition = {
                top: fakeRangeBounds.top + fakeWindowOffsets.pageYOffset,
                left: fakeRangeBounds.left + fakeRangeBounds.width/2 + fakeWindowOffsets.pageXOffset
              };

          before(function() {
            window.pageXOffset = fakeWindowOffsets.pageXOffset;
            window.pageYOffset = fakeWindowOffsets.pageYOffset;
            window.innerWidth = fakeWindowBounds.innerWidth;
            window.innerHeight = fakeWindowBounds.innerHeight;
          });

          beforeEach(function() {
            fakeRange = {
              getBoundingClientRect: function() {
                return fakeRangeBounds;
              }
            };
          });

          describe('positioning', function() {
            it('should update styling when position changes', function() {
              var top = 200,
                  left = 100;

              // Must set using Polymers, so as to trigger any observers
              component.set('position.top', top);
              component.set('position.left', left);

              expect(component.style.top).to.equal(top + 'px');
              expect(component.style.left).to.equal(left + 'px');
            });

            it('should be inside viewport at all times', function() {
              var componentBounds;
              component.active = true;

              sinon.stub(fakeRange, 'getBoundingClientRect').returns(fakeRangeOutsideBounds);
              component.range = fakeRange;
              componentBounds = component.getBoundingClientRect();

              expect(componentBounds.top).to.be.at.least(window.pageYOffset);
              expect(componentBounds.left).to.be.at.least(window.pageXOffset);
            });
          });

          describe('range', function() {
            it('should update position on change of range', function() {
              component.range = fakeRange;

              expect(component.position.left).to.equal(fakeToolbarPosition.left);
              expect(component.position.top).to.equal(fakeToolbarPosition.top);
            });

            it('should be updated on scribe events', function() {
              component.scribe.trigger('selectionchange', [{
                position: null,
                range: fakeRange
              }]);

              expect(component.range).to.equal(fakeRange);
            });
          });
        });

        describe('active / inactive', function() {
          it('should become active when select is fired', function() {
            component.active = false;
            component.scribe.trigger('select');
            expect(component.active).to.be.true;
          });

          it('should become inactive when deselect is fired', function() {
            component.active = true;
            component.scribe.trigger('deselect');
            expect(component.active).to.be.false;
          });
        });
      });
    </script>
  </body>
</html>
